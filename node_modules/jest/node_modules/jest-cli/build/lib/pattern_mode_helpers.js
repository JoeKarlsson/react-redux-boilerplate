/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';var _chalk;

function _load_chalk() {return _chalk = _interopRequireDefault(require('chalk'));}var _ansiEscapes;
function _load_ansiEscapes() {return _ansiEscapes = _interopRequireDefault(require('ansi-escapes'));}var _stringLength;
function _load_stringLength() {return _stringLength = _interopRequireDefault(require('string-length'));}var _stripAnsi;
function _load_stripAnsi() {return _stripAnsi = _interopRequireDefault(require('strip-ansi'));}var _Prompt;
function _load_Prompt() {return _Prompt = _interopRequireDefault(require('./Prompt'));}function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}

const pluralize = (count, text) =>
count === 1 ? text : text + 's';

const printPatternMatches = function (
count,
entity,
pipe)

{let extraText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  const pluralized = pluralize(count, entity);
  const result = count ?
  `\n\n Pattern matches ${count} ${pluralized}` :
  `\n\n Pattern matches no ${pluralized}`;

  pipe.write(result + extraText);
};

const printPatternCaret = (
pattern,
pipe) =>
{
  const inputText = `${(_chalk || _load_chalk()).default.dim(' pattern \u203A')} ${pattern}`;

  pipe.write((_ansiEscapes || _load_ansiEscapes()).default.eraseDown);
  pipe.write(inputText);
  pipe.write((_ansiEscapes || _load_ansiEscapes()).default.cursorSavePosition);
};

const printRestoredPatternCaret = (
pattern,
currentUsageRows,
pipe) =>
{
  const inputText = `${(_chalk || _load_chalk()).default.dim(' pattern \u203A')} ${pattern}`;

  pipe.write(
  (_ansiEscapes || _load_ansiEscapes()).default.cursorTo((0, (_stringLength || _load_stringLength()).default)(inputText), currentUsageRows - 1));

  pipe.write((_ansiEscapes || _load_ansiEscapes()).default.cursorRestorePosition);
};

const printStartTyping = (
entity,
pipe) =>
{
  pipe.write(
  `\n\n ${(_chalk || _load_chalk()).default.italic.yellow(
  `Start typing to filter by a ${entity} regex pattern.`)
  }`);

};

const printMore = (
entity,
pipe,
more) =>
{
  pipe.write(
  `\n   ${(_chalk || _load_chalk()).default.dim(`...and ${more} more ${pluralize(more, entity)}`)}`);

};

const printTypeaheadItem = (
item,
pipe) =>
pipe.write(`\n ${(_chalk || _load_chalk()).default.dim('\u203A')} ${item}`);

const formatTypeaheadSelection = (
item,
index,
activeIndex,
prompt) =>
{
  if (index === activeIndex) {
    prompt.setTypheadheadSelection((0, (_stripAnsi || _load_stripAnsi()).default)(item));
    return (_chalk || _load_chalk()).default.black.bgYellow((0, (_stripAnsi || _load_stripAnsi()).default)(item));
  }
  return item;
};

module.exports = {
  formatTypeaheadSelection,
  printMore,
  printPatternCaret,
  printPatternMatches,
  printRestoredPatternCaret,
  printStartTyping,
  printTypeaheadItem };